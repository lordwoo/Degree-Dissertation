
package framework;

import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.HashMap;
import java.util.Map;

/**
 * <p>
 * Represents a web form submitted to the server. Developers can extend this
 * class with their own concrete implementation, providing a field for each
 * field of the web form, annotated with {@link FormField}. Custom validation
 * rules can be implemented by writing methods in the class and annotating them
 * with {@link Validation}. It is not necessary to write any constructors, as
 * all construction and initialisation is handled by the framework.
 *
 * <p>
 * Note that any concrete implementation should be declared {@code final}, as
 * validation will only take place on the fields in the calling class, not any
 * of it's parents.
 */
public abstract class Form
{
    private Map<String, String[]> formData;
    private Map<String, String> errorMsgs = new HashMap<>();

    /**
     * @return the HTTP form data
     */
    public Map<String, String[]> getFormData()
    {
        return formData;
    }

    /**
     * @param formData HTTP form data
     */
    public void setFormData(Map<String, String[]> formData)
    {
        this.formData = formData;
    }

    /**
     * @return any error messages generated by validation
     */
    public Map<String, String> getErrorMsgs()
    {
        return errorMsgs;
    }

    // setErrorMsgs() omitted; should only be set in validate()
    
    /**
     * A convenience method to add a form validation error message. If the error
     * message map already contains a message for the designated field, the new
     * message will be ignored.
     *
     * @param field the name of the field
     * @param message the error message
     */
    public void addErrorMsg(String field, String message)
    {
        if (!errorMsgs.containsKey(field))
        {
            errorMsgs.put(field, message);
        }
    }

    /**
     * Validates the form data by validating each field in the extending
     * subclass that is annotated with the {@link FormField} annotation and
     * calling all the extending subclass' methods that are annotated with the
     * {@link Validation} annotation.
     *
     * @return true if the form data validated successfully (no error messages
     * produced), false otherwise
     */
    public boolean validate()
    {
        // Clear any old error messages
        errorMsgs.clear();

        // For each field in the calling class
        for (Field field : getClass().getDeclaredFields())
        {
            // If the field is a FormField, validate it
            if (field.isAnnotationPresent(FormField.class))
            {
                validateField(field);
            }
        }

        // For each method in the calling class
        for (Method method : getClass().getDeclaredMethods())
        {
            // If the method is a Validation method, invoke it
            if (method.isAnnotationPresent(Validation.class))
            {
                try
                {
                    method.invoke(this);
                }
                catch (IllegalAccessException | IllegalArgumentException | InvocationTargetException e)
                {
                    throw new RuntimeException(e);
                }
            }
        }

        return errorMsgs.isEmpty();
    }

    /**
     * Validates a form field.
     *
     * @param field the field to be validated
     */
    private void validateField(Field field)
    {
        FormField formField = field.getAnnotation(FormField.class);
        String name = field.getName();
        String displayName = formField.displayName();

        if (!formData.containsKey(name))
        {
            if (formField.required())
            {
                errorMsgs.put(name, displayName + " must be entered.");
            }
        }
        else
        {
            String value = formData.get(name)[0].trim();
            if (value.isEmpty())
            {
                if (formField.required())
                {
                    errorMsgs.put(name, displayName + " must be entered.");
                }
            }
            else
            {
                field.setAccessible(true);
                // Call type-specific validation methods
                Class type = field.getType();
                if (type.equals(String.class))
                {
                    validateAsString(field, value);
                }
                else if (type.equals(int.class) || type.equals(Integer.class))
                {
                    validateAsInt(field, value);
                }
                else if (type.equals(double.class) || type.equals(Double.class))
                {
                    validateAsDouble(field, value);
                }
                else if (type.isEnum())
                {
                    validateAsEnum(field, value);
                }
                else
                {
                    throw new RuntimeException("FormField type \"" + type.getSimpleName() + "\" not valid value.");
                }
            }
        }
    }

    private void validateAsString(Field field, String value)
    {
        FormField formField = field.getAnnotation(FormField.class);
        String name = field.getName();
        String displayName = formField.displayName();

        if (value.length() < formField.minLength())
        {
            errorMsgs.put(name, displayName + " must be " + formField.minLength()
                    + " characters or more.");
        }
        else if (value.length() > formField.maxLength())
        {
            errorMsgs.put(name, displayName + " must be " + formField.maxLength()
                    + " characters or less.");
        }
        else
        {
            try
            {
                field.set(this, value);
            }
            catch (IllegalAccessException e)
            {
                // This implies a programming error
                throw new RuntimeException(e);
            }
        }
    }

    private void validateAsInt(Field field, String value)
    {
        String name = field.getName();
        FormField formField = field.getAnnotation(FormField.class);
        String displayName = formField.displayName();

        int valueInt;
        try
        {
            valueInt = Integer.parseInt(value);
            if (valueInt < formField.min())
            {
                errorMsgs.put(name, displayName + " must be at least " + (int) formField.min() + ".");
            }
            else if (valueInt > formField.max())
            {
                errorMsgs.put(name, displayName + " must not be greater than " + (int) formField.max() + ".");
            }

            field.set(this, valueInt);
        }
        catch (NumberFormatException e)
        {
            errorMsgs.put(name, displayName + " must be a whole number.");
        }
        catch (IllegalAccessException e)
        {
            throw new RuntimeException(e);
        }
    }

    private void validateAsDouble(Field field, String value)
    {
        String name = field.getName();
        FormField formField = field.getAnnotation(FormField.class);
        String displayName = formField.displayName();

        double valueDouble;
        try
        {
            valueDouble = Double.parseDouble(value);
            if (valueDouble < formField.min())
            {
                errorMsgs.put(name, displayName + " must be at least " + formField.min() + ".");
            }
            else if (valueDouble > formField.max())
            {
                errorMsgs.put(name, displayName + " must not be greater than " + formField.max() + ".");
            }
            else
            {
                field.set(this, valueDouble);
            }
        }
        catch (NumberFormatException e)
        {
            errorMsgs.put(name, displayName + " must be a number.");
        }
        catch (IllegalAccessException e)
        {
            throw new RuntimeException(e);
        }
    }

    private void validateAsEnum(Field field, String value)
    {
        try
        {
            field.set(this, Enum.valueOf((Class) field.getType(), value.toUpperCase()));
        }
        catch (IllegalArgumentException e)
        {
            // This can arise either from malformed user input, or from a programming
            // error (mismatch between HTTP parameter value and enum value); logging
            // in the event of the latter
            FormField formField = field.getAnnotation(FormField.class);
            errorMsgs.put(field.getName(), formField.displayName() + " may not be " + value + ".");
            // TODO: Error logging needed
        }
        catch (IllegalAccessException e)
        {
            // This implies a programming error
            throw new RuntimeException(e);
        }
    }
}
